"""
Improvement algorithms for Flow Shop Scheduling Problem.

This module implements local search and metaheuristic techniques
to improve initial solutions generated by constructive heuristics.
"""

from typing import List, Tuple, Callable
import random
import copy
from makespan import calculate_makespan


def two_opt_swap(sequence: List[int], i: int, j: int) -> List[int]:
    """
    Perform a 2-opt swap on a sequence.
    
    Args:
        sequence (List[int]): Original sequence
        i (int): First position
        j (int): Second position
        
    Returns:
        List[int]: New sequence with positions i and j swapped
    """
    new_sequence = sequence.copy()
    new_sequence[i], new_sequence[j] = new_sequence[j], new_sequence[i]
    return new_sequence


def insert_move(sequence: List[int], from_pos: int, to_pos: int) -> List[int]:
    """
    Move a job from one position to another.
    
    Args:
        sequence (List[int]): Original sequence
        from_pos (int): Position to move from
        to_pos (int): Position to move to
        
    Returns:
        List[int]: New sequence with job moved
    """
    new_sequence = sequence.copy()
    job = new_sequence.pop(from_pos)
    new_sequence.insert(to_pos, job)
    return new_sequence


def local_search_2opt(processing_times: List[List[float]], 
                     initial_sequence: List[int],
                     max_iterations: int = 1000) -> Tuple[List[int], float]:
    """
    Improve a sequence using 2-opt local search.
    
    Args:
        processing_times (List[List[float]]): Matrix of processing times
        initial_sequence (List[int]): Starting sequence
        max_iterations (int): Maximum number of iterations
        
    Returns:
        Tuple[List[int], float]: (best_sequence, best_makespan)
    """
    current_sequence = initial_sequence.copy()
    current_makespan = calculate_makespan(processing_times, current_sequence)
    
    improved = True
    iterations = 0
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try all possible 2-opt swaps
        for i in range(len(current_sequence)):
            for j in range(i + 1, len(current_sequence)):
                # Create new sequence with swap
                new_sequence = two_opt_swap(current_sequence, i, j)
                new_makespan = calculate_makespan(processing_times, new_sequence)
                
                # Accept if improvement found
                if new_makespan < current_makespan:
                    current_sequence = new_sequence
                    current_makespan = new_makespan
                    improved = True
                    break
            
            if improved:
                break
    
    return current_sequence, current_makespan


def local_search_insert(processing_times: List[List[float]], 
                       initial_sequence: List[int],
                       max_iterations: int = 1000) -> Tuple[List[int], float]:
    """
    Improve a sequence using insertion-based local search.
    
    Args:
        processing_times (List[List[float]]): Matrix of processing times
        initial_sequence (List[int]): Starting sequence
        max_iterations (int): Maximum number of iterations
        
    Returns:
        Tuple[List[int], float]: (best_sequence, best_makespan)
    """
    current_sequence = initial_sequence.copy()
    current_makespan = calculate_makespan(processing_times, current_sequence)
    
    improved = True
    iterations = 0
    
    while improved and iterations < max_iterations:
        improved = False
        iterations += 1
        
        # Try all possible insertions
        for from_pos in range(len(current_sequence)):
            for to_pos in range(len(current_sequence)):
                if from_pos == to_pos:
                    continue
                
                # Create new sequence with insertion
                new_sequence = insert_move(current_sequence, from_pos, to_pos)
                new_makespan = calculate_makespan(processing_times, new_sequence)
                
                # Accept if improvement found
                if new_makespan < current_makespan:
                    current_sequence = new_sequence
                    current_makespan = new_makespan
                    improved = True
                    break
            
            if improved:
                break
    
    return current_sequence, current_makespan


def variable_neighborhood_search(processing_times: List[List[float]], 
                               initial_sequence: List[int],
                               max_iterations: int = 100) -> Tuple[List[int], float]:
    """
    Improve a sequence using Variable Neighborhood Search (VNS).
    
    Args:
        processing_times (List[List[float]]): Matrix of processing times
        initial_sequence (List[int]): Starting sequence
        max_iterations (int): Maximum number of iterations
        
    Returns:
        Tuple[List[int], float]: (best_sequence, best_makespan)
    """
    current_sequence = initial_sequence.copy()
    current_makespan = calculate_makespan(processing_times, current_sequence)
    
    # Define neighborhood structures
    neighborhoods = [
        lambda seq: local_search_2opt(processing_times, seq, 50)[0],
        lambda seq: local_search_insert(processing_times, seq, 50)[0]
    ]
    
    for iteration in range(max_iterations):
        improved = False
        
        for neighborhood in neighborhoods:
            # Apply neighborhood search
            new_sequence = neighborhood(current_sequence)
            new_makespan = calculate_makespan(processing_times, new_sequence)
            
            if new_makespan < current_makespan:
                current_sequence = new_sequence
                current_makespan = new_makespan
                improved = True
                break
        
        if not improved:
            # Perform random perturbation
            current_sequence = random_perturbation(current_sequence, 2)
    
    return current_sequence, current_makespan


def random_perturbation(sequence: List[int], num_swaps: int = 1) -> List[int]:
    """
    Apply random perturbation to a sequence.
    
    Args:
        sequence (List[int]): Original sequence
        num_swaps (int): Number of random swaps to perform
        
    Returns:
        List[int]: Perturbed sequence
    """
    new_sequence = sequence.copy()
    
    for _ in range(num_swaps):
        i = random.randint(0, len(new_sequence) - 1)
        j = random.randint(0, len(new_sequence) - 1)
        new_sequence[i], new_sequence[j] = new_sequence[j], new_sequence[i]
    
    return new_sequence


class GeneticAlgorithm:
    """
    Genetic Algorithm implementation for Flow Shop Scheduling.
    """
    
    def __init__(self, processing_times: List[List[float]], 
                 population_size: int = 50,
                 mutation_rate: float = 0.1,
                 crossover_rate: float = 0.8,
                 elite_size: int = 5):
        """
        Initialize Genetic Algorithm parameters.
        
        Args:
            processing_times (List[List[float]]): Matrix of processing times
            population_size (int): Size of population
            mutation_rate (float): Probability of mutation
            crossover_rate (float): Probability of crossover
            elite_size (int): Number of elite individuals to preserve
        """
        self.processing_times = processing_times
        self.population_size = population_size
        self.mutation_rate = mutation_rate
        self.crossover_rate = crossover_rate
        self.elite_size = elite_size
        self.num_jobs = len(processing_times)
    
    def create_random_individual(self) -> List[int]:
        """Create a random job sequence."""
        sequence = list(range(self.num_jobs))
        random.shuffle(sequence)
        return sequence
    
    def initialize_population(self, initial_sequence: List[int] = None) -> List[List[int]]:
        """
        Initialize population with random individuals and optionally an initial sequence.
        
        Args:
            initial_sequence (List[int], optional): Good initial sequence to include
            
        Returns:
            List[List[int]]: Population of sequences
        """
        population = []
        
        # Add initial sequence if provided
        if initial_sequence:
            population.append(initial_sequence.copy())
        
        # Fill rest with random individuals
        while len(population) < self.population_size:
            population.append(self.create_random_individual())
        
        return population
    
    def fitness(self, sequence: List[int]) -> float:
        """
        Calculate fitness (inverse of makespan).
        
        Args:
            sequence (List[int]): Job sequence
            
        Returns:
            float: Fitness value
        """
        makespan = calculate_makespan(self.processing_times, sequence)
        return 1.0 / (1.0 + makespan)  # Higher fitness for lower makespan
    
    def selection(self, population: List[List[int]], num_parents: int) -> List[List[int]]:
        """
        Tournament selection for parent selection.
        
        Args:
            population (List[List[int]]): Current population
            num_parents (int): Number of parents to select
            
        Returns:
            List[List[int]]: Selected parents
        """
        parents = []
        tournament_size = 3
        
        for _ in range(num_parents):
            # Tournament selection
            tournament = random.sample(population, min(tournament_size, len(population)))
            winner = max(tournament, key=self.fitness)
            parents.append(winner.copy())
        
        return parents
    
    def order_crossover(self, parent1: List[int], parent2: List[int]) -> Tuple[List[int], List[int]]:
        """
        Order crossover (OX) for permutation representation.
        
        Args:
            parent1 (List[int]): First parent
            parent2 (List[int]): Second parent
            
        Returns:
            Tuple[List[int], List[int]]: Two offspring
        """
        size = len(parent1)
        
        # Choose two random crossover points
        start = random.randint(0, size - 1)
        end = random.randint(start + 1, size)
        
        # Create offspring
        offspring1 = [-1] * size
        offspring2 = [-1] * size
        
        # Copy segments from parents
        offspring1[start:end] = parent1[start:end]
        offspring2[start:end] = parent2[start:end]
        
        # Fill remaining positions
        self._fill_offspring(offspring1, parent2, start, end)
        self._fill_offspring(offspring2, parent1, start, end)
        
        return offspring1, offspring2
    
    def _fill_offspring(self, offspring: List[int], parent: List[int], start: int, end: int):
        """Helper method to fill offspring in order crossover."""
        parent_idx = end % len(parent)
        offspring_idx = end % len(offspring)
        
        for _ in range(len(parent)):
            if parent[parent_idx] not in offspring:
                while offspring[offspring_idx] != -1:
                    offspring_idx = (offspring_idx + 1) % len(offspring)
                offspring[offspring_idx] = parent[parent_idx]
            parent_idx = (parent_idx + 1) % len(parent)
    
    def mutate(self, sequence: List[int]) -> List[int]:
        """
        Swap mutation for permutation representation.
        
        Args:
            sequence (List[int]): Original sequence
            
        Returns:
            List[int]: Mutated sequence
        """
        if random.random() < self.mutation_rate:
            mutated = sequence.copy()
            i = random.randint(0, len(mutated) - 1)
            j = random.randint(0, len(mutated) - 1)
            mutated[i], mutated[j] = mutated[j], mutated[i]
            return mutated
        return sequence.copy()
    
    def evolve(self, generations: int = 100, initial_sequence: List[int] = None) -> Tuple[List[int], float]:
        """
        Run the genetic algorithm.
        
        Args:
            generations (int): Number of generations to run
            initial_sequence (List[int], optional): Good initial sequence
            
        Returns:
            Tuple[List[int], float]: (best_sequence, best_makespan)
        """
        # Initialize population
        population = self.initialize_population(initial_sequence)
        
        best_sequence = None
        best_makespan = float('inf')
        
        for generation in range(generations):
            # Evaluate population
            fitness_scores = [(seq, self.fitness(seq)) for seq in population]
            fitness_scores.sort(key=lambda x: x[1], reverse=True)
            
            # Update best solution
            current_best = fitness_scores[0][0]
            current_makespan = calculate_makespan(self.processing_times, current_best)
            
            if current_makespan < best_makespan:
                best_makespan = current_makespan
                best_sequence = current_best.copy()
            
            # Create new population
            new_population = []
            
            # Elitism: keep best individuals
            for i in range(min(self.elite_size, len(fitness_scores))):
                new_population.append(fitness_scores[i][0].copy())
            
            # Generate offspring
            while len(new_population) < self.population_size:
                # Selection
                parents = self.selection(population, 2)
                
                # Crossover
                if random.random() < self.crossover_rate:
                    offspring1, offspring2 = self.order_crossover(parents[0], parents[1])
                else:
                    offspring1, offspring2 = parents[0].copy(), parents[1].copy()
                
                # Mutation
                offspring1 = self.mutate(offspring1)
                offspring2 = self.mutate(offspring2)
                
                new_population.extend([offspring1, offspring2])
            
            # Trim population to exact size
            population = new_population[:self.population_size]
        
        return best_sequence, best_makespan


def apply_improvements(processing_times: List[List[float]], 
                      initial_sequence: List[int],
                      methods: List[str] = None) -> Tuple[List[int], float, dict]:
    """
    Apply multiple improvement methods and return the best result.
    
    Args:
        processing_times (List[List[float]]): Matrix of processing times
        initial_sequence (List[int]): Starting sequence
        methods (List[str], optional): List of methods to apply
        
    Returns:
        Tuple[List[int], float, dict]: (best_sequence, best_makespan, results_summary)
    """
    if methods is None:
        methods = ['2opt', 'insert', 'vns', 'genetic']
    
    results = {}
    best_sequence = initial_sequence.copy()
    best_makespan = calculate_makespan(processing_times, initial_sequence)
    
    results['initial'] = (initial_sequence.copy(), best_makespan)
    
    # Apply each improvement method
    for method in methods:
        try:
            if method == '2opt':
                seq, makespan = local_search_2opt(processing_times, initial_sequence)
                results['2opt'] = (seq, makespan)
                
            elif method == 'insert':
                seq, makespan = local_search_insert(processing_times, initial_sequence)
                results['insert'] = (seq, makespan)
                
            elif method == 'vns':
                seq, makespan = variable_neighborhood_search(processing_times, initial_sequence)
                results['vns'] = (seq, makespan)
                
            elif method == 'genetic':
                ga = GeneticAlgorithm(processing_times)
                seq, makespan = ga.evolve(generations=50, initial_sequence=initial_sequence)
                results['genetic'] = (seq, makespan)
            
            # Update best if improvement found
            if makespan < best_makespan:
                best_makespan = makespan
                best_sequence = seq.copy()
                
        except Exception as e:
            print(f"Warning: Error in {method} improvement: {e}")
            continue
    
    return best_sequence, best_makespan, results


def print_improvement_results(results: dict, job_names: List[str] = None) -> None:
    """
    Print results of improvement methods.
    
    Args:
        results (dict): Results from apply_improvements
        job_names (List[str], optional): Names of jobs for display
    """
    if job_names is None:
        num_jobs = len(results['initial'][0])
        job_names = [f"Job_{i+1}" for i in range(num_jobs)]
    
    print(f"\n=== Improvement Results ===")
    print(f"{'Method':<10} {'Makespan':<10} {'Improvement':<12}")
    print("-" * 35)
    
    initial_makespan = results['initial'][1]
    
    for method, (sequence, makespan) in results.items():
        if method == 'initial':
            improvement = "baseline"
        else:
            improvement = f"{((initial_makespan - makespan) / initial_makespan * 100):.1f}%"
        
        print(f"{method.capitalize():<10} {makespan:<10.2f} {improvement:<12}")
    
    print("=" * 35)
